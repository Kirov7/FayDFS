// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.20.1
// source: proto/faydfs.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// C2NClient is the client API for C2N service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type C2NClient interface {
	// 获取文件位置并操作元数据 （应在datanode返回给client之前进行元数据修改）
	GetFileLocationAndModifyMeta(ctx context.Context, in *FileNameAndMode, opts ...grpc.CallOption) (*FileLocationArr, error)
	// 创建文件
	CreateFile(ctx context.Context, in *FileNameAndMode, opts ...grpc.CallOption) (*FileLocationArr, error)
	// Delete 和 Mkdir
	OperateMeta(ctx context.Context, in *FileNameAndOperateMode, opts ...grpc.CallOption) (*OperateStatus, error)
	// Rename
	RenameFileInMeta(ctx context.Context, in *SrcAndDestPath, opts ...grpc.CallOption) (*OperateStatus, error)
	// Stat
	GetFileMeta(ctx context.Context, in *PathName, opts ...grpc.CallOption) (*FileMeta, error)
	// List
	GetDirMeta(ctx context.Context, in *PathName, opts ...grpc.CallOption) (*DirMetaList, error)
	// 告知metanode，datanode数据传输完成
	PutSuccess(ctx context.Context, in *MetaStore, opts ...grpc.CallOption) (*OperateStatus, error)
	// 更新租约
	RenewLock(ctx context.Context, in *GetLease, opts ...grpc.CallOption) (*OperateStatus, error)
}

type c2NClient struct {
	cc grpc.ClientConnInterface
}

func NewC2NClient(cc grpc.ClientConnInterface) C2NClient {
	return &c2NClient{cc}
}

func (c *c2NClient) GetFileLocationAndModifyMeta(ctx context.Context, in *FileNameAndMode, opts ...grpc.CallOption) (*FileLocationArr, error) {
	out := new(FileLocationArr)
	err := c.cc.Invoke(ctx, "/proto.C2N/GetFileLocationAndModifyMeta", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *c2NClient) CreateFile(ctx context.Context, in *FileNameAndMode, opts ...grpc.CallOption) (*FileLocationArr, error) {
	out := new(FileLocationArr)
	err := c.cc.Invoke(ctx, "/proto.C2N/CreateFile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *c2NClient) OperateMeta(ctx context.Context, in *FileNameAndOperateMode, opts ...grpc.CallOption) (*OperateStatus, error) {
	out := new(OperateStatus)
	err := c.cc.Invoke(ctx, "/proto.C2N/OperateMeta", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *c2NClient) RenameFileInMeta(ctx context.Context, in *SrcAndDestPath, opts ...grpc.CallOption) (*OperateStatus, error) {
	out := new(OperateStatus)
	err := c.cc.Invoke(ctx, "/proto.C2N/RenameFileInMeta", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *c2NClient) GetFileMeta(ctx context.Context, in *PathName, opts ...grpc.CallOption) (*FileMeta, error) {
	out := new(FileMeta)
	err := c.cc.Invoke(ctx, "/proto.C2N/GetFileMeta", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *c2NClient) GetDirMeta(ctx context.Context, in *PathName, opts ...grpc.CallOption) (*DirMetaList, error) {
	out := new(DirMetaList)
	err := c.cc.Invoke(ctx, "/proto.C2N/GetDirMeta", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *c2NClient) PutSuccess(ctx context.Context, in *MetaStore, opts ...grpc.CallOption) (*OperateStatus, error) {
	out := new(OperateStatus)
	err := c.cc.Invoke(ctx, "/proto.C2N/PutSuccess", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *c2NClient) RenewLock(ctx context.Context, in *GetLease, opts ...grpc.CallOption) (*OperateStatus, error) {
	out := new(OperateStatus)
	err := c.cc.Invoke(ctx, "/proto.C2N/RenewLock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// C2NServer is the server API for C2N service.
// All implementations must embed UnimplementedC2NServer
// for forward compatibility
type C2NServer interface {
	// 获取文件位置并操作元数据 （应在datanode返回给client之前进行元数据修改）
	GetFileLocationAndModifyMeta(context.Context, *FileNameAndMode) (*FileLocationArr, error)
	// 创建文件
	CreateFile(context.Context, *FileNameAndMode) (*FileLocationArr, error)
	// Delete 和 Mkdir
	OperateMeta(context.Context, *FileNameAndOperateMode) (*OperateStatus, error)
	// Rename
	RenameFileInMeta(context.Context, *SrcAndDestPath) (*OperateStatus, error)
	// Stat
	GetFileMeta(context.Context, *PathName) (*FileMeta, error)
	// List
	GetDirMeta(context.Context, *PathName) (*DirMetaList, error)
	// 告知metanode，datanode数据传输完成
	PutSuccess(context.Context, *MetaStore) (*OperateStatus, error)
	// 更新租约
	RenewLock(context.Context, *GetLease) (*OperateStatus, error)
	mustEmbedUnimplementedC2NServer()
}

// UnimplementedC2NServer must be embedded to have forward compatible implementations.
type UnimplementedC2NServer struct {
}

func (UnimplementedC2NServer) GetFileLocationAndModifyMeta(context.Context, *FileNameAndMode) (*FileLocationArr, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFileLocationAndModifyMeta not implemented")
}
func (UnimplementedC2NServer) CreateFile(context.Context, *FileNameAndMode) (*FileLocationArr, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateFile not implemented")
}
func (UnimplementedC2NServer) OperateMeta(context.Context, *FileNameAndOperateMode) (*OperateStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OperateMeta not implemented")
}
func (UnimplementedC2NServer) RenameFileInMeta(context.Context, *SrcAndDestPath) (*OperateStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RenameFileInMeta not implemented")
}
func (UnimplementedC2NServer) GetFileMeta(context.Context, *PathName) (*FileMeta, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFileMeta not implemented")
}
func (UnimplementedC2NServer) GetDirMeta(context.Context, *PathName) (*DirMetaList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDirMeta not implemented")
}
func (UnimplementedC2NServer) PutSuccess(context.Context, *MetaStore) (*OperateStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PutSuccess not implemented")
}
func (UnimplementedC2NServer) RenewLock(context.Context, *GetLease) (*OperateStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RenewLock not implemented")
}
func (UnimplementedC2NServer) mustEmbedUnimplementedC2NServer() {}

// UnsafeC2NServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to C2NServer will
// result in compilation errors.
type UnsafeC2NServer interface {
	mustEmbedUnimplementedC2NServer()
}

func RegisterC2NServer(s grpc.ServiceRegistrar, srv C2NServer) {
	s.RegisterService(&C2N_ServiceDesc, srv)
}

func _C2N_GetFileLocationAndModifyMeta_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FileNameAndMode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(C2NServer).GetFileLocationAndModifyMeta(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.C2N/GetFileLocationAndModifyMeta",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(C2NServer).GetFileLocationAndModifyMeta(ctx, req.(*FileNameAndMode))
	}
	return interceptor(ctx, in, info, handler)
}

func _C2N_CreateFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FileNameAndMode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(C2NServer).CreateFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.C2N/CreateFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(C2NServer).CreateFile(ctx, req.(*FileNameAndMode))
	}
	return interceptor(ctx, in, info, handler)
}

func _C2N_OperateMeta_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FileNameAndOperateMode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(C2NServer).OperateMeta(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.C2N/OperateMeta",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(C2NServer).OperateMeta(ctx, req.(*FileNameAndOperateMode))
	}
	return interceptor(ctx, in, info, handler)
}

func _C2N_RenameFileInMeta_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SrcAndDestPath)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(C2NServer).RenameFileInMeta(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.C2N/RenameFileInMeta",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(C2NServer).RenameFileInMeta(ctx, req.(*SrcAndDestPath))
	}
	return interceptor(ctx, in, info, handler)
}

func _C2N_GetFileMeta_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PathName)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(C2NServer).GetFileMeta(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.C2N/GetFileMeta",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(C2NServer).GetFileMeta(ctx, req.(*PathName))
	}
	return interceptor(ctx, in, info, handler)
}

func _C2N_GetDirMeta_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PathName)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(C2NServer).GetDirMeta(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.C2N/GetDirMeta",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(C2NServer).GetDirMeta(ctx, req.(*PathName))
	}
	return interceptor(ctx, in, info, handler)
}

func _C2N_PutSuccess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MetaStore)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(C2NServer).PutSuccess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.C2N/PutSuccess",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(C2NServer).PutSuccess(ctx, req.(*MetaStore))
	}
	return interceptor(ctx, in, info, handler)
}

func _C2N_RenewLock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLease)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(C2NServer).RenewLock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.C2N/RenewLock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(C2NServer).RenewLock(ctx, req.(*GetLease))
	}
	return interceptor(ctx, in, info, handler)
}

// C2N_ServiceDesc is the grpc.ServiceDesc for C2N service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var C2N_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.C2N",
	HandlerType: (*C2NServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetFileLocationAndModifyMeta",
			Handler:    _C2N_GetFileLocationAndModifyMeta_Handler,
		},
		{
			MethodName: "CreateFile",
			Handler:    _C2N_CreateFile_Handler,
		},
		{
			MethodName: "OperateMeta",
			Handler:    _C2N_OperateMeta_Handler,
		},
		{
			MethodName: "RenameFileInMeta",
			Handler:    _C2N_RenameFileInMeta_Handler,
		},
		{
			MethodName: "GetFileMeta",
			Handler:    _C2N_GetFileMeta_Handler,
		},
		{
			MethodName: "GetDirMeta",
			Handler:    _C2N_GetDirMeta_Handler,
		},
		{
			MethodName: "PutSuccess",
			Handler:    _C2N_PutSuccess_Handler,
		},
		{
			MethodName: "RenewLock",
			Handler:    _C2N_RenewLock_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/faydfs.proto",
}

// C2DClient is the client API for C2D service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type C2DClient interface {
	// 从块中读取数据
	GetBlock(ctx context.Context, in *FileNameAndMode, opts ...grpc.CallOption) (C2D_GetBlockClient, error)
	// 向指定块写入数据
	WriteBlock(ctx context.Context, opts ...grpc.CallOption) (C2D_WriteBlockClient, error)
}

type c2DClient struct {
	cc grpc.ClientConnInterface
}

func NewC2DClient(cc grpc.ClientConnInterface) C2DClient {
	return &c2DClient{cc}
}

func (c *c2DClient) GetBlock(ctx context.Context, in *FileNameAndMode, opts ...grpc.CallOption) (C2D_GetBlockClient, error) {
	stream, err := c.cc.NewStream(ctx, &C2D_ServiceDesc.Streams[0], "/proto.C2D/GetBlock", opts...)
	if err != nil {
		return nil, err
	}
	x := &c2DGetBlockClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type C2D_GetBlockClient interface {
	Recv() (*File, error)
	grpc.ClientStream
}

type c2DGetBlockClient struct {
	grpc.ClientStream
}

func (x *c2DGetBlockClient) Recv() (*File, error) {
	m := new(File)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *c2DClient) WriteBlock(ctx context.Context, opts ...grpc.CallOption) (C2D_WriteBlockClient, error) {
	stream, err := c.cc.NewStream(ctx, &C2D_ServiceDesc.Streams[1], "/proto.C2D/WriteBlock", opts...)
	if err != nil {
		return nil, err
	}
	x := &c2DWriteBlockClient{stream}
	return x, nil
}

type C2D_WriteBlockClient interface {
	Send(*FileWriteStream) error
	CloseAndRecv() (*OperateStatus, error)
	grpc.ClientStream
}

type c2DWriteBlockClient struct {
	grpc.ClientStream
}

func (x *c2DWriteBlockClient) Send(m *FileWriteStream) error {
	return x.ClientStream.SendMsg(m)
}

func (x *c2DWriteBlockClient) CloseAndRecv() (*OperateStatus, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(OperateStatus)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// C2DServer is the server API for C2D service.
// All implementations must embed UnimplementedC2DServer
// for forward compatibility
type C2DServer interface {
	// 从块中读取数据
	GetBlock(*FileNameAndMode, C2D_GetBlockServer) error
	// 向指定块写入数据
	WriteBlock(C2D_WriteBlockServer) error
	mustEmbedUnimplementedC2DServer()
}

// UnimplementedC2DServer must be embedded to have forward compatible implementations.
type UnimplementedC2DServer struct {
}

func (UnimplementedC2DServer) GetBlock(*FileNameAndMode, C2D_GetBlockServer) error {
	return status.Errorf(codes.Unimplemented, "method GetBlock not implemented")
}
func (UnimplementedC2DServer) WriteBlock(C2D_WriteBlockServer) error {
	return status.Errorf(codes.Unimplemented, "method WriteBlock not implemented")
}
func (UnimplementedC2DServer) mustEmbedUnimplementedC2DServer() {}

// UnsafeC2DServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to C2DServer will
// result in compilation errors.
type UnsafeC2DServer interface {
	mustEmbedUnimplementedC2DServer()
}

func RegisterC2DServer(s grpc.ServiceRegistrar, srv C2DServer) {
	s.RegisterService(&C2D_ServiceDesc, srv)
}

func _C2D_GetBlock_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(FileNameAndMode)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(C2DServer).GetBlock(m, &c2DGetBlockServer{stream})
}

type C2D_GetBlockServer interface {
	Send(*File) error
	grpc.ServerStream
}

type c2DGetBlockServer struct {
	grpc.ServerStream
}

func (x *c2DGetBlockServer) Send(m *File) error {
	return x.ServerStream.SendMsg(m)
}

func _C2D_WriteBlock_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(C2DServer).WriteBlock(&c2DWriteBlockServer{stream})
}

type C2D_WriteBlockServer interface {
	SendAndClose(*OperateStatus) error
	Recv() (*FileWriteStream, error)
	grpc.ServerStream
}

type c2DWriteBlockServer struct {
	grpc.ServerStream
}

func (x *c2DWriteBlockServer) SendAndClose(m *OperateStatus) error {
	return x.ServerStream.SendMsg(m)
}

func (x *c2DWriteBlockServer) Recv() (*FileWriteStream, error) {
	m := new(FileWriteStream)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// C2D_ServiceDesc is the grpc.ServiceDesc for C2D service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var C2D_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.C2D",
	HandlerType: (*C2DServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetBlock",
			Handler:       _C2D_GetBlock_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "WriteBlock",
			Handler:       _C2D_WriteBlock_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "proto/faydfs.proto",
}

// N2DClient is the client API for N2D service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type N2DClient interface {
	// 从datanode中获取块的位置信息
	GetBlockReport(ctx context.Context, in *Ping, opts ...grpc.CallOption) (*BlockReplicaList, error)
}

type n2DClient struct {
	cc grpc.ClientConnInterface
}

func NewN2DClient(cc grpc.ClientConnInterface) N2DClient {
	return &n2DClient{cc}
}

func (c *n2DClient) GetBlockReport(ctx context.Context, in *Ping, opts ...grpc.CallOption) (*BlockReplicaList, error) {
	out := new(BlockReplicaList)
	err := c.cc.Invoke(ctx, "/proto.N2D/GetBlockReport", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// N2DServer is the server API for N2D service.
// All implementations must embed UnimplementedN2DServer
// for forward compatibility
type N2DServer interface {
	// 从datanode中获取块的位置信息
	GetBlockReport(context.Context, *Ping) (*BlockReplicaList, error)
	mustEmbedUnimplementedN2DServer()
}

// UnimplementedN2DServer must be embedded to have forward compatible implementations.
type UnimplementedN2DServer struct {
}

func (UnimplementedN2DServer) GetBlockReport(context.Context, *Ping) (*BlockReplicaList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlockReport not implemented")
}
func (UnimplementedN2DServer) mustEmbedUnimplementedN2DServer() {}

// UnsafeN2DServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to N2DServer will
// result in compilation errors.
type UnsafeN2DServer interface {
	mustEmbedUnimplementedN2DServer()
}

func RegisterN2DServer(s grpc.ServiceRegistrar, srv N2DServer) {
	s.RegisterService(&N2D_ServiceDesc, srv)
}

func _N2D_GetBlockReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Ping)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(N2DServer).GetBlockReport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.N2D/GetBlockReport",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(N2DServer).GetBlockReport(ctx, req.(*Ping))
	}
	return interceptor(ctx, in, info, handler)
}

// N2D_ServiceDesc is the grpc.ServiceDesc for N2D service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var N2D_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.N2D",
	HandlerType: (*N2DServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetBlockReport",
			Handler:    _N2D_GetBlockReport_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/faydfs.proto",
}

// D2NClient is the client API for D2N service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type D2NClient interface {
	// 每3s向namenode发送一次心跳
	DatanodeHeartbeat(ctx context.Context, in *Heartbeat, opts ...grpc.CallOption) (*DatanodeOperation, error)
	// 每1h向namenode汇报一次block状态
	BlockReport(ctx context.Context, in *BlockReplicaList, opts ...grpc.CallOption) (*OperateStatus, error)
	// 向namenode进行注册
	RegisterDataNode(ctx context.Context, in *RegisterDataNodeReq, opts ...grpc.CallOption) (*OperateStatus, error)
}

type d2NClient struct {
	cc grpc.ClientConnInterface
}

func NewD2NClient(cc grpc.ClientConnInterface) D2NClient {
	return &d2NClient{cc}
}

func (c *d2NClient) DatanodeHeartbeat(ctx context.Context, in *Heartbeat, opts ...grpc.CallOption) (*DatanodeOperation, error) {
	out := new(DatanodeOperation)
	err := c.cc.Invoke(ctx, "/proto.D2N/DatanodeHeartbeat", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *d2NClient) BlockReport(ctx context.Context, in *BlockReplicaList, opts ...grpc.CallOption) (*OperateStatus, error) {
	out := new(OperateStatus)
	err := c.cc.Invoke(ctx, "/proto.D2N/BlockReport", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *d2NClient) RegisterDataNode(ctx context.Context, in *RegisterDataNodeReq, opts ...grpc.CallOption) (*OperateStatus, error) {
	out := new(OperateStatus)
	err := c.cc.Invoke(ctx, "/proto.D2N/RegisterDataNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// D2NServer is the server API for D2N service.
// All implementations must embed UnimplementedD2NServer
// for forward compatibility
type D2NServer interface {
	// 每3s向namenode发送一次心跳
	DatanodeHeartbeat(context.Context, *Heartbeat) (*DatanodeOperation, error)
	// 每1h向namenode汇报一次block状态
	BlockReport(context.Context, *BlockReplicaList) (*OperateStatus, error)
	// 向namenode进行注册
	RegisterDataNode(context.Context, *RegisterDataNodeReq) (*OperateStatus, error)
	mustEmbedUnimplementedD2NServer()
}

// UnimplementedD2NServer must be embedded to have forward compatible implementations.
type UnimplementedD2NServer struct {
}

func (UnimplementedD2NServer) DatanodeHeartbeat(context.Context, *Heartbeat) (*DatanodeOperation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DatanodeHeartbeat not implemented")
}
func (UnimplementedD2NServer) BlockReport(context.Context, *BlockReplicaList) (*OperateStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BlockReport not implemented")
}
func (UnimplementedD2NServer) RegisterDataNode(context.Context, *RegisterDataNodeReq) (*OperateStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterDataNode not implemented")
}
func (UnimplementedD2NServer) mustEmbedUnimplementedD2NServer() {}

// UnsafeD2NServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to D2NServer will
// result in compilation errors.
type UnsafeD2NServer interface {
	mustEmbedUnimplementedD2NServer()
}

func RegisterD2NServer(s grpc.ServiceRegistrar, srv D2NServer) {
	s.RegisterService(&D2N_ServiceDesc, srv)
}

func _D2N_DatanodeHeartbeat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Heartbeat)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(D2NServer).DatanodeHeartbeat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.D2N/DatanodeHeartbeat",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(D2NServer).DatanodeHeartbeat(ctx, req.(*Heartbeat))
	}
	return interceptor(ctx, in, info, handler)
}

func _D2N_BlockReport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockReplicaList)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(D2NServer).BlockReport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.D2N/BlockReport",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(D2NServer).BlockReport(ctx, req.(*BlockReplicaList))
	}
	return interceptor(ctx, in, info, handler)
}

func _D2N_RegisterDataNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterDataNodeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(D2NServer).RegisterDataNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.D2N/RegisterDataNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(D2NServer).RegisterDataNode(ctx, req.(*RegisterDataNodeReq))
	}
	return interceptor(ctx, in, info, handler)
}

// D2N_ServiceDesc is the grpc.ServiceDesc for D2N service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var D2N_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.D2N",
	HandlerType: (*D2NServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "DatanodeHeartbeat",
			Handler:    _D2N_DatanodeHeartbeat_Handler,
		},
		{
			MethodName: "BlockReport",
			Handler:    _D2N_BlockReport_Handler,
		},
		{
			MethodName: "RegisterDataNode",
			Handler:    _D2N_RegisterDataNode_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/faydfs.proto",
}
